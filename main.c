#include "gba.h"
#include "logic.h"
#include "draw.h"
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:

#include "images/title.h"

#include <stdio.h>

// AppState enum definition
typedef enum {
    // TA-TODO: Add any additional states you need for your app.
    START,
    START_NODRAW,
    APP_INIT,
    RESPAWN,
    DIED,
    NEXT_LEVEL,
    APP,
    PAUSE,
    APP_EXIT,
    APP_EXIT_NODRAW,
} GBAState;

int main(void) {

    REG_DISPCNT = MODE3 | BG2_ENABLE;

    // Manipulate REG_DISPCNT here to set Mode 3.

    GBAState state = START;

    // We store the "previous" and "current" states.
    AppState currentAppState, nextAppState;

    int timer = 0;

    // We store the current and previous values of the button input.
    u32 previousButtons = BUTTONS;
    u32 currentButtons = BUTTONS;

    while (1) {
        // Load the current state of the buttons
        currentButtons = BUTTONS;

        // Manipulate the state machine below as needed.
        switch(state) {
            case START:
                waitForVBlank();

                // Initialize and draw title screen
                initializeAppState(&currentAppState);
                drawFullScreenImageDMA(title);

                state = START_NODRAW;
                break;
            case START_NODRAW:
                // Check for a button press here to start the app.
                // Start the app by switching the state to APP_INIT.

                if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    state = APP_INIT;
                    undrawReady();
                }

                break;
            case APP_INIT:
                // Draw the initial state of the app
                fullDrawAppState(&currentAppState);

                state = RESPAWN;
                break;
            case RESPAWN:

                // Pause at the start and get rid of "Ready" afterwards
                waitForVBlank();
                timer++;
                if (timer >= TRANSITION_DELAY) {
                    state = APP;
                    timer = 0;
                    undrawReady();
                }
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                }
                break;
            case DIED:

                waitForVBlank();

                // Pause on death and reset the player and ghosts
                timer++;
                if (timer >= TRANSITION_DELAY) {
                    timer = 0;
                    if (currentAppState.lives == 0) {
                        state = APP_EXIT;
                    } else {
                        undrawAppState(&currentAppState);
                        processDeath(&currentAppState);
                        drawAppState(&currentAppState);
                        drawLives(&currentAppState);
                        drawReady();
                        state = RESPAWN;
                    }
                }
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                }
                break;
            case APP:
                // Process the app for one frame, store the next state
                nextAppState = processAppState(&currentAppState, currentButtons);

                // Wait for VBlank before we do any drawing.
                waitForVBlank();

                undrawAppState(&currentAppState);
                drawAppState(&nextAppState);

                // Now set the current state as the next state for the next iter.
                currentAppState = nextAppState;

                // If dead, go to death transition
                if (nextAppState.gameOver) {
                    state = DIED;
                }
                // If beat the level, go to the next level transition
                if (nextAppState.win) {
                    state = NEXT_LEVEL;
                }
                if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    state = PAUSE;
                }
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                }
                break;
            case PAUSE:
                // Draw the pause screen and wait for the start button to resume
                drawPaused();
                if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    undrawPaused();
                    state = APP;
                }
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                }
                break;
            case NEXT_LEVEL:
                waitForVBlank();

                // Pause on beating the level and then reset the map for the next level
                timer++;
                if (timer >= TRANSITION_DELAY) {
                    state = RESPAWN;
                    timer = 0;
                    currentAppState.win = 0;
                    undrawAppState(&currentAppState);
                    processWin(&currentAppState);
                    drawAllDots(&currentAppState);
                    drawAppState(&currentAppState);
                    drawLevel(&currentAppState);
                    drawLives(&currentAppState);
                    drawReady();
                }
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
                    state = START;
                }
                break;
            case APP_EXIT:
                // Wait for VBlank
                waitForVBlank();

                // Draw the exit / gameover screen
                drawGameover(&currentAppState);

                state = APP_EXIT_NODRAW;
                break;
            case APP_EXIT_NODRAW:
                // TA-TODO: Check for a button press here to go back to the start screen
                if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons) || KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
                    state = START;
                }
                break;
        }

        // Store the current state of the buttons
        previousButtons = currentButtons;
    }

    return 0;
}
